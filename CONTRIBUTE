# How to contribute to the project
Fork the repository under your namespace (by clicking the fork button on the top right).

## Create and setup your virtual environment
Clone the forked repository to your local machine and create a virtual environment by running the following command:
```bash
python3 -m venv env
```

Activate the virtual environment by running the following command:
```bash
source env/bin/activate
```

Install `uv` if you don't have it installed:
```bash
pip install uv
```

`uv` is a command-line tool for managing and running Python applications in isolated environments. It is known to be faster installing dependencies than `pip`. It comes with a lot of features that make it easier to work with Python projects, such as dependency management, virtual environments, and more.

Install the global and dev dependencies by running the following command:
```bash
uv pip install -r requirements.txt -r requirements-dev.txt
```

## Setup pre-commit hooks
This project uses pre-commit hooks to ensure code quality and consistency. Pre-commit hooks are scripts that run automatically before you commit your changes to the repository. They can help catch common mistakes and enforce coding standards. To setup pre-commit hooks, you need to run the following command:

```bash
pre-commit install
```

## Setup the PostgreSQL database
This project relies on PostgreSQL with PostGIS for spatial data handling. You need to have PostgreSQL and PostGIS installed on your machine. To do so, you need to install the following packages using your package manager:

```bash
sudo apt install \                                                 
    postgresql-16 \        
    postgresql-16-postgis-3 \
    postgresql-server-dev-16
```

Log into the PostgreSQL database as the `postgres` user and create a new database `insaroule`: 

```bash
sudo -i -u postgres
createdb insaroule
```
While you are logged in as the `postgres` user, you will also create a user `insaroule_user` with password `insaroule_password` to access the database. You can do this by running the following commands in the PostgreSQL shell (by running `psql` command):

```sql
CREATE USER insaroule_user WITH PASSWORD 'insaroule_password';
GRANT ALL PRIVILEGES ON DATABASE insaroule TO insaroule_user;
```

Connect to the `insaroule` database as the `postgres` user and grant the necessary privileges to the `insaroule_user` user:

```sql
\c insaroule
GRANT CREATE ON SCHEMA public TO insaroule_user;
```

While you are at it, you can also create a PostGIS extension for the `insaroule` database by running the following command in the PostgreSQL shell:

```sql
CREATE EXTENSION postgis;
```

You can now quit the PostgreSQL shell by running the following command:

```sql
\q
```

and exit the `postgres` user by running:

```bash
exit
```

## Setup Redis
This project uses Redis to handle background tasks and chat messages. You need to have Redis installed and running on your machine.

You can install Redis using your package manager. For example, on Ubuntu, you can run the following commands:
```bash
sudo apt-get install lsb-release curl gpg
curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg
sudo chmod 644 /usr/share/keyrings/redis-archive-keyring.gpg
echo "deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/redis.list
sudo apt-get update
sudo apt-get install redis
```

Redis will start automatically, and it should restart at boot time. If Redis doesn't start across reboots, you may need to manually enable it:

```bash
sudo systemctl enable redis-server
sudo systemctl start redis-server
```

Sources: [Redis on Linux documentation](https://redis.io/docs/latest/operate/oss_and_stack/install/archive/install-redis/install-redis-on-linux/)

## Run the background tasks worker
As it was mentioned above, this project uses Redis to handle background tasks. To run the background tasks worker, you need to run the following command inside the `project` directory:

```bash
celery -A project worker --loglevel=info
```

NB: This command need to run when the `uvicorn` server is running, so you can open a new terminal window and run this command in parallel with the `uvicorn` server.


## Run the application
As the project is an asynchronous Django application, you can run it using the `uvicorn` development server. To do this, run the following command inside the `project` directory:

```bash
uvicorn project.asgi:application --reload --reload-include "*.html"
```

## Run the tests
This project uses Django's built-in testing framework to run tests. Try to write and run tests for your changes to ensure that everything works as expected. You can run the tests by running the following command inside the `project` directory:

```bash
python manage.py test
```

## Run the GitHub Actions locally
It may be useful to run the GitHub Actions locally to ensure that everything works as expected before pushing your changes to the repository. You need first to install the `act` tool (see https://github.com/nektos/act). 
Once installed you can run the following command in the root directory of the project to run the GitHub Actions locally:

```bash
~/bin/act 
```

NB: To run `act` you need to have Docker installed and running on your machine. `act` will use Docker to run the GitHub Actions workflows in isolated containers.

## Translations
You need first to install GNU gettext tools to work with translations. You can install it using your package manager. For example, on Ubuntu, you can run the following command:

```bash
sudo apt-get install gettext
```

You can update the translation files by running the following command:

```bash
python manage.py makemessages -l <language_code>
```

Replace `<language_code>` with the language code you are working on (e.g., `fr` for French, `en` for English, etc.). After making your changes to the translation files, if you want to see the changes reflected in the application, you can compile the translations by running:

```bash
python manage.py compilemessages
```

The compiled translations won't be committed to the repository, as they are generated files. If you want to have translations available in your local environment, you need to run the `compilemessages` command.



## Commit your changes
Commit your changes with a descriptive message (you could link the issue you are working on for example using `#<issue_number>` in the commit message). Then push your changes to your forked repository. 

Once you are done with your changes, you can create a pull request to the main repository. To do this, follow these steps:
* Go to the main repository and click on the "Pull requests" tab
* Click on the "New pull request" button
* Select the branch you want to merge into (usually `develop`)
* Select the branch you want to merge from (your forked repository)
* Add a title and description for your pull request
* Assign the pull request to the appropriate person (usually the maintainer of the repository)
* Add any relevant labels or milestones
* Click on the "Create pull request" button
* Wait for the maintainer to review your pull request and make any necessary changes
* Once the pull request is approved, it will be merged into the main repository

